# Create image base on 'node' image (latest version), pulling it from hub.docker
FROM node

# Change working dir to '/app'(create '/app' and go inside it), which means that all further commands will be executed from '/app'
WORKDIR /app

# Optimization for executing layers. First install all depandancies then coppy all code source in case code would be changed
COPY package.json /app

# Run command
RUN npm install

# Copy all files/folders from '.' path (root, where Dockerfile exists) to '.' path (root) in container
# COPY . .
# if WORKDIR set up we can use either 'COPY . .' or 'COPY . ./' or 'COPY . /app'
COPY . /app

# Let docker know that when container starts we want to expose port 80 to local machine, which runs this contaier
# It just clarifes port, but actually does nothing
EXPOSE 80

# Anonymous volume. It will be deleted if remove container
VOLUME [ "/app/feedback" ]

# It starts app during image creation/building, but it's inncorrect because image is just template. Do not do it!
# RUN node server.js

# It runs command only during start of container
CMD ["node", "server.js"]

----------------------------------------------------------------------------------------------------------------
- Build docker image base Dickerfile in root
docker build .

- Run docker container from image. You can use only few first ID sympols like "f5dffbb96bb3ad76ef4c7"
docker run f5dffbb96bb3ad76ef4c781f96db877dd57d570ef672a77b6bb7e3651b9a32a2

- Get all running docker containers
docker ps

- Get all existing docker containers
docker ps -a

- Stop container by name
docker stop friendly_elion

- Create NEW container and Expose/Publish(-p) local port 3000 (which port shpould be accessable) with internal port 80 inside container
docker run -p 3000:80 ae4e16965ad800a7faa8f07d66148249fe68daa88344938616207a3b3e7fdbfb

- Docker caches all instruction(lines in Dockerfile). It re-builds only changed layer. Therefore it can re-builds faster second time than very first.
- If one layer changed, Docker re-executes this one and all following.
- Every instruction in an image creates a cacheable layer.

- Check available option for cirtain commands
docker COMMAND --help
docker build --help 

- Start existing container, which was stopped before. Do not need create new container(docker run ...) if you didn't change image.
docker start container_name_id

- Attached mode - default for 'docker run'. Listening output of container, for example consol output.
docker run image_id
docker start -a container_name_id
docker attach container_name_id

- Detached mode - default for 'docker start'. The process in terminal finishes immediately. The container is running in the background.
docker start container_name_id
docker run -d container_name_id

- See the last logs in container
docker logs container_name_id

- See the last logs and follow log output in container
docker logs -f container_name_id

- Allocate a pseudo-TTY and keep STDIN open even if not attached. So we can input something via console if app needs.
docker run -it e38a6e781747027fb1ceefe9fa

- Start container with open STDIN(--attach and --interactive)
docker start -a -i awesome_fermi

- Remove container, but you need to stop it before
docker stop container_name_id
docker rm container_name_1 container_name_2 container_name_3

- Get list of all images
docker images

- Remove images, but you need to remove container before
docker rmi e38a6e781747

- Remove all unused images
docker image prune

- Automatically remove the container (--rm) when it exits (in case below it will be removed after stoping)
- Actually usefull when you need to rebuild image after some changes
docker run -p 3000:80 -d --rm 138689ba4848
docker stop busy_moser

- Display detailed information on one or more images
docker image inspect 138689ba4848

- Copy file from local machine to docker container
docker cp dummy/file.txt container_name:/app/test

- Copy file from docker container to local machine
docker cp container_name:/app/test dummy/file.txt

- Run/Create container with name 'goalsapp'
docker run -p 3000:80 -d --rm --name goalsapp 138689ba48485b88d3b8befe3952a1aa

- Image tag: "<name>:<tag>". For example "node:12"
-t Name and optionally a tag (format: "name:tag")
docker build -t goals:latest .
docker run -p 3001:80 -d --rm --name goalsapp2 goals:latest

- Rename image name:tag 
docker tag nodeapp:latest forelock/node-hello-world:latest

- Push docker image to hub.docker.commands (create before repo on docker hub)
docker login
docker push forelock/node-hello-world:latest

- Pull image from hub.docker.com
docker pull forelock/node-hello-world

- Get list of volumes
docker volume ls

- Anonymous volumes created in Dockerfile, but named volumes created during run container
docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes

- Delete volume
docker volume rm VOL_NAME
docker volume prune

- Type of data storage: Volumes(Anonymous and Named - managed by docker) and Bind Mounts(Managed by you)
- check before resources are shared with docker(local dir should be shared - Docker Desktop/settings/resources
- Anonymous Volume: "-v /app/node_modules" - overides particular dirs (if their more specific) from Bind Mount to save something that was created during image building
+ 1) Created specifically for a single container
+ 2) Survives container shutdown / restart - unless --rm is used
+ 3) Can not be shared across containers
+ 4) Since it's anonymous, it can't be re-used for same container (even same image)
- Named Volume: "-v feedback:/app/feedback" - for saving results when we stop/remove containers.
+ 1) Created in general - not tied to any specific container
+ 2) Survives container shutdown / restart - removal via Docker clarifes
+ 3) Can be shared across containers
+ 4) Can be re-used for same container (across restarts)
- Bind Mount: "-v "/Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/5-data-volumes-01-starting-setup:/app""" - for using code outside container, helps us to update code and do not re-build image.
+ 1) Location on host file system, not tied to any sppecific container
+ 2) Survives container shutdown / restart - removal on host fs
+ 3) Can be shared across containers
+ 4) Can be re-used for same container (across restarts)
- In this case DO NOT NEED VOLUME instaraction in Dockerfile
docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "/Users/.../5-data-volumes-01-starting-setup:/app" -v /app/node_modules feedback-node:volumes

- Shortcuts:
macOS / Linux: -v $(pwd):/app
Windows: -v "%cd%":/app

- If we use some specific project like web-server on node.js, we might need to stop and start container again to apply some changes: use dependancy kind of "nodemon"

- Bind Mount Volume is in read/write mode. It can be made as read only by adding ':ro' to the end. So we exclude '/app/temp' and '/app/node_modules' from Bind Mount
docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "/Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/5-data-volumes-01-starting-setup:/app:ro" -v /app/temp -v /app/node_modules feedback-node:volumes

- Create Named Volume
docker volume create feedback-files

- Get infor about volume:
docker volume inspect feedback-files

- Remove volume if unused (need to stop/remove container before)
docker volume rm feedback-files

- Remove all unused volumes
docker volume prune

- Mostly Bind Mount is not used in production. It just needed for development

- To ignore some files/dirs during 'COPY' instruction need to add them to '.dockerignore' file